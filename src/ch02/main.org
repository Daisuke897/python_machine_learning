分類問題 単純な機械学習アルゴリズムの訓練
* 取り上げる内容
** 機械学習のアルゴリズムを理解する
** pandas, NumPy, matplotlibを使ってデータの読み込み、処理、可視化を行う
** 線形分類のアルゴリズムをPythonで実装する
* パーセプトロンの学習アルゴリズムをPythonで実装する
#+begin_src emacs-lisp
  (pyvenv-activate "~/project/python_machine_learning")
#+end_src

#+RESULTS:

** オブジェクト指向のパーセプトロンAPI
#+begin_src python :session
  import numpy as np


  class Perception(object):
      """パーセプトロンの分類器"""

      def __init__(self, eta=0.01, n_iter=50, random_state=1):
          self.eta = eta
          self.n_iter = n_iter
          self.random_state = random_state

      def fit(self, X, y):
          """訓練データに適合させる"""
          rgen = np.random.RandomState(self.random_state)
          # 正規分布に従う乱数を生成
          # locは平均、scaleは標準偏差である。
          self.w_ = rgen.normal(loc=0.0, scale=0.01, size=1 + X.shape[1])
          self.errors_ = []

          for _ in range(self.n_iter):
              errors = 0
              for xi, target in zip(X, y):
                  update = self.eta * (target - self.predict(xi))
                  self.w_[1:] += update * xi
                  self.w_[0] += update
                  errors += int(update != 0.0)
              self.errors_.append(errors)
          return self

      def net_input(self, X):
          """Calculate net input"""
          return np.dot(X, self.w_[1:]) + self.w_[0]

      def predict(self, X):
          """Return class label after unit step"""
          return np.where(self.net_input(X) >= 0.0, 1, -1)
#+end_src

#+RESULTS:

#+begin_src python :session
  v1 = np.array([1, 2, 3])
  v2 = 0.5 * v1
  np.arccos(v1.dot(v2) / (np.linalg.norm(v1) * np.linalg.norm(v2)))
#+end_src

#+RESULTS:
: 0.0

#+begin_src python :session
  import pandas as pd

  s = 'https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data'

  df = pd.read_csv(s, header=None, encoding="utf-8")

  df.tail()
#+end_src

#+RESULTS:
:        0    1    2    3               4
: 145  6.7  3.0  5.2  2.3  Iris-virginica
: 146  6.3  2.5  5.0  1.9  Iris-virginica
: 147  6.5  3.0  5.2  2.0  Iris-virginica
: 148  6.2  3.4  5.4  2.3  Iris-virginica
: 149  5.9  3.0  5.1  1.8  Iris-virginica

Iris-setosaの50枚の花とIris-versicolorの50枚の花に対応する先頭の100個のクラスレベルを抽出する
#+begin_src python :session
  # 1-100行目の目的変数を抽出
  y = df.iloc[0:100, 4].values
  # Iris-setosaを-1, Iris-versicolorを1に変換
  y = np.where(y == "Itis-setosa", -1, 1)
  # 1-100行目の1, 3列目を抽出
  X = df.iloc[0:100, [0, 2]].values
#+end_src

#+RESULTS:

#+begin_src python :session :results file link
  import matplotlib.pyplot as plt

  plt.close('all')

  plt.scatter(X[:50, 0], X[:50, 1],
              color="red", marker='o', label="setosa")
  plt.scatter(X[50:100, 0], X[50:100, 1],
              color="blue", marker='x', label="versicolor")

  plt.xlabel("sepal length [cm]")
  plt.ylabel("pepal length [cm]")
  plt.legend(loc="upper left")

  fname = "images/02_06.png"
  plt.savefig(fname)
  fname
#+end_src

#+RESULTS:
[[file:images/02_06.png]]

#+begin_src python :session :results file link
  plt.close('all')

  ppn = Perception(eta=0.1, n_iter=10)

  ppn.fit(X, y)

  plt.plot(range(1, len(ppn.errors_) + 1), ppn.errors_, marker='o')
  plt.xlabel('Epochs')
  plt.ylabel('Number of updates')

  fname = 'images/02_07.png'

  plt.savefig('images/02_07.png')

  fname
#+end_src

#+RESULTS:
[[file:images/02_07.png]]

2次元のデータセットの決定境界を可視化したい

#+begin_src python :session :results file link
  from matplotlib.colors import ListedColormap

  def plot_decision_regions(X, y, classifier, resolution = 0.02):

      # マーカーとカラーマップの準備
      markers = ('s', 'x', 'o', '^', 'v')
      colors = ('red', 'blue', 'lightgreen', 'gray', 'cyan')
      cmap = ListedColormap(colors[:len(np.unique(y))])

      # 決定領域のプロット
      x1_min, x1_max = X[:, 0].min() - 1, X[:, 0].max() + 1
      x2_min, x2_max = X[:, 1].min() - 1, X[:, 1].max() + 1
      # グリッドポイントの生成
      xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, resolution),
                             np.arange(x2_min, x2_max, resolution))
      # 各特徴量を1次元配列に変換して予測を実行
      Z = classifier.predict(np.array([xx1.ravel(), xx2.ravel()]).T)
#+end_src
